<html>
<head>
<title>GLB+VRM viewer</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<style>
.container {
    position: relative;
    overflow: hidden;
}
#ui {
    background-color: transparent;  /* set 2D canvas to overlap webgl canvas and be transparent*/
    position: absolute;
    left: 0px;
    top: 0px;
    z-index: 10;
    overflow: hidden;
}

body {
  position: relative;
  margin: 0;
  padding: 0;
  overflow: hidden;
}
</style>

<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript" src="HoloRenderer.js"></script>
<script type="text/javascript" src="InterfaceButton.js"></script>
<script type="text/javascript" src="ExecutionMode.js"></script>
<script type="text/javascript" src="generated/api.js"></script>
<script type="text/javascript" src="Serializer.js"></script>
<script type="text/javascript" src="HoloMode.js"></script>
<script type="text/javascript" src="TableClient.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">#version 300 es
    // Fragment shader for rendering multi-image holograms
    precision mediump float;

    
    uniform vec3 view_position ; //camera position
	in vec3 v_position; // point on render mesh in world space
	
    // Hologram packeted into textures by type
    const int texture_width = 1024;
    uniform sampler2D floats;
    uniform mediump isampler2D ints;
    uniform lowp usampler2D bytes;
	

	out vec4 frag_color; // output color

    void main(void) {

		frag_color = vec4(1.0f, 0.5f, 1.0f, 1.0f);	
    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
    // A very simple passthrough vertex shader
	in vec3 input_vertex_position;
   
    uniform mat4 mv_matrix;
    uniform mat4 p_matrix;

	out vec3 v_position;

    void main(void) {
        gl_Position = p_matrix * mv_matrix * vec4(input_vertex_position, 1.0);
		v_position = input_vertex_position; 
    }
</script>

<script type="text/javascript">
"use strict";
const url_params = new URLSearchParams(window.location.search) ;
var app; // The main app running on the CAD canvas
var imports = url_params.get("import") ? url_params.get("import").split(',') : [];

var tools  ; // a map containing several things above so execution modes can access them
var views = 0, panels = 0 ;
var filename = "test";

function canvasApp() {
    //The canvas this app is running on.
	var theCanvas = document.getElementById("ui");
	// 2D context you can use to draw on.
    var context = theCanvas.getContext("2d");

    var mouse_x, mouse_y, mouse_down_x, mouse_down_y ;
    


	function init() {
        // Add event listeners to the canvas or window as appropriate
		theCanvas.addEventListener("mousedown", mouseDownListener, false);
		window.addEventListener("mousemove", mouseMoveListener, false);
		window.addEventListener("mouseup", mouseUpListener, false);
		window.addEventListener('keydown',keyDownListener,false);
		window.addEventListener('keyup',keyUpListener,false);
		window.addEventListener('mousewheel', mouseWheelListener);//For Chrome
        window.addEventListener('DOMMouseScroll', mouseWheelListener);// For Firefox

        //touchHandler simulates mouse events on single touch
		document.addEventListener("touchstart", touchHandler, true);
		document.addEventListener("touchmove", touchHandler, true);
		document.addEventListener("touchend", touchHandler, true);
		document.addEventListener("touchcancel", touchHandler, true);


        //document.addEventListener('pointermove', pointerMove, true) ;

        window.setInterval(timeListener, 1000.0/120.0);
	}

    function timeListener(){

        if(tools.current_mode!=null){
            if(tools.renderer.has_new_xr_input){
                tools.current_mode.vrInputSourcesUpdated(tools.renderer.xr_input);
                tools.renderer.has_new_xr_input = false;
            }
            tools.current_mode.timer();  

        }

        /*
        if(tools.table_link != null && tools.table_link.ready() && !tools.table_link.active){
            tools.table_link.sendPendingRequests(true); // This works to start even if there aren't any pending requests yet
        }
        */
    }

	function keyDownListener(evt) {
        if(tools.current_mode!=null){
            tools.current_mode.keyDownListener(evt);
        }
	}

	function keyUpListener(evt) {
        if(tools.current_mode!=null){
            tools.current_mode.keyUpListener(evt);
        }
    }

    // Map touchevents
	function touchHandler(event){
		//event.preventDefault();
		var touches = event.touches;
		var pointers = [];
		for(let k=0;k<touches.length;k++){
            //TODO get position relative to canvas if canvas isn't whole screen?
            /*
            this.mouse_down_x = (event.clientX - bRect.left)*(tools.canvas.width/bRect.width);
            this.mouse_down_y = (event.clientY - bRect.top)*(tools.canvas.height/bRect.height);
            */
			pointers.push({x: touches[k].clientX, y: touches[k].clientY, button:10}); // using 10 for touch events
		}
		switch(event.type)
		{
			case "touchstart": pointerDown(pointers); break;
			case "touchmove":  pointerMove(pointers); break;
			case "touchend":  pointerUp(pointers);   break;
			default:           return;
		}
	}

	function mouseDownListener(event) {
		pointerDown([{x:event.clientX, y:event.clientY, button:event.button}]);
    }

	function mouseMoveListener(event){
		pointerMove([{x:event.clientX, y:event.clientY, button:event.button}]);
	}
	function mouseUpListener(event){
		pointerUp([]); // On mouse up there are no pointers down
	}

 

	function pointerDown(pointers) {

        if(tools.renderer.xr_session != null){ // Kill XR session if interacting with canvas
            tools.renderer.xr_session.end().then(tools.renderer.onXRSessionEnded);
        }

		mouse_down_x = pointers[0].x;
        mouse_down_y = pointers[0].y;

        // Buttons are executed in mouse up, this just prevents calling underlying mode when clicking a button.
        let pressed_button = false;
        for (let button_name in tools.buttons) {
            if (tools.buttons.hasOwnProperty(button_name)) {
                var b = tools.buttons[button_name];
                if( b.inside(mouse_down_x, mouse_down_y)){
                    pressed_button = true;
                }
            }
        }

        if(tools.current_mode!=null && !pressed_button){
            tools.current_mode.pointerDown(pointers);
        }
	}

	function pointerUp(pointers) {
        // Execute buttons if it was clicked (mouse down and up on it)
        let pressed_button = false;
        for (let button_name in tools.buttons) {
            if (tools.buttons.hasOwnProperty(button_name)) {
                var b = tools.buttons[button_name];
                if(b.inside(mouse_x, mouse_y) && b.inside(mouse_down_x, mouse_down_y)){
                    b.execute();
                    pressed_button = true;
                }
            }
        }

        if(tools.current_mode!=null && !pressed_button){
            tools.current_mode.pointerUp(pointers);
        }
	}

	function pointerMove(pointers) {
        if(pointers.x){ // not an array, must be a real pointer event
            pointers.preventDefault()
            pointers = [{x:pointers.x,y:pointers.y}];
        }
        mouse_x = pointers[0].x;
		mouse_y = pointers[0].y;
        if(tools.current_mode!=null){
            tools.current_mode.pointerMove(pointers);
        }
    }

	function mouseWheelListener(evt){
        if(tools.current_mode!=null){
            tools.current_mode.mouseWheelListener(evt);
        }
	}



    init(); //TODO this a janky way to boot up an app, maybe change it?
}

// Switch main execution mode (expects mode to be an ExecutionMode)
function switchExecutionMode(next_mode){
    if(tools.current_mode != null){
        tools.current_mode.exit(next_mode);
    }
    var last_mode = tools.current_mode ;
    tools.current_mode = next_mode ;
    next_mode.enter(last_mode);

}


function initializeModes(){
    tools.modes = {} ;
    tools.modes.holo_mode = new HoloMode(tools);
    switchExecutionMode(tools.modes.holo_mode) ;
}

function setMainMenuButtons(){
    tools.buttons = {};
    tools.buttons["fps_label"] = new InterfaceButton(tools.canvas.width-80, 10, 80, 40, "FPS:?", 20, "#FFFFFF", "#000000", "#000000", 3, null);
    tools.buttons["views_label"] = new InterfaceButton(tools.canvas.width-90, 70, 90, 40, "views:0", 20, "#FFFFFF", "#000000", "#000000", 3, null);
    tools.buttons["enter_vr"] = new InterfaceButton(5, 10, 100, 40, "Enter VR", 14, "#D0D0F0", "#606060", "#FFFFFF", 3, () => {tools.renderer.startXRSession();});
    tools.buttons["resetView"] = new InterfaceButton(5, 50, 100, 40, "Reset View", 14, "#D0D0F0", "#606060", "#FFFFFF", 3, resetView);
    tools.buttons["holo_trace"] = new InterfaceButton(5, 150, 100, 40, "CPU trace", 14, "#D0D0F0", "#606060", "#FFFFFF", 3, holoTrace);
    tools.buttons["clear_trace"] = new InterfaceButton(5, 190, 100, 40, "Clear Trace", 14, "#D0D0F0", "#606060", "#FFFFFF", 3, clearTrace);
}

function onBodyLoad(){
    tools = {};
    tools.renderer = new HoloRenderer("webgl", "ui", "shader-fs", "shader-vs", 100);
    tools.canvas = document.getElementById("ui"); ;

    // Wait for the WASM module to finish loading before booting up the socket and app
    window.initializeCPPAPI().then(function(Module){
        tools.API = Module ;
        //tools.table_link = new TableClient(9004, tools.API);
        app = canvasApp(); // Start the app
        initializeModes();
        setMainMenuButtons();
    });
}

function loadFile() {

    var file  = document.getElementById('loader').files[0];
    console.log(file) ;
    var ext = file.name.split(".");
    filename = ext[ext.length-2] ;
    ext = ext[ext.length-1].toLowerCase();
    

	var reader  = new FileReader();
	reader.onloadend = function () {
        let load_data = new Int8Array(reader.result);
        //console.log(reader.result);
        if(load_data!= null){
            let params = {};
            params.data = load_data;
            if(ext == "glb" || ext == "vrm"){
                tools.renderer.removeMesh("default_avatar");
                let m = tools.API.call("setModel", params, new Serializer()) ;
            }else if(ext == "hi1"){
                let m = tools.API.call("loadHologram", load_data, new Serializer(), false,true) ;
                views = m.views ;
                panels=m.panels;
                tools.buttons["views_label"].text = "views: " + views;
            }else{
                console.log("file extension not recognized:" + ext);
            }
        }
    }

	if (file) {
		reader.readAsArrayBuffer(file);
	} else {
		console.log("Failed to read file");
	}
}


function getCameraTraceInput(){
    var trace_input ={};
    trace_input.width = tools.canvas.width;
    trace_input.height = tools.canvas.height;
    trace_input.camera_pos = new Float32Array(3);
    for(var k=0;k<3;k++){
        trace_input.camera_pos[k] = tools.renderer.camera_pos[k];
    }
    trace_input.pMatrix = new Float32Array(16);
    trace_input.mvMatrix = new Float32Array(16);
    for(var k=0;k<16;k++){
        trace_input.pMatrix[k] = tools.renderer.pMatrix[k];
        trace_input.mvMatrix[k] = tools.renderer.mvMatrix[k];
    }
    return trace_input ;
}

function holoTrace(){
    var context = tools.canvas.getContext("2d");;
    var image = context.createImageData(tools.canvas.width, tools.canvas.height);
    //console.log("Holo Tracing " + image.width +" x " + image.height +"...");
    
    let trace_input = getCameraTraceInput();
    //console.log("trace_input:");
    //console.log(trace_input);
    var trace_output = tools.API.call("getHologramTraceImage",trace_input, new Serializer());
    for(var k=0;k<trace_output.image.length;k++){
        image.data[k] = trace_output.image[k] >= 0  ? trace_output.image[k] : trace_output.image[k] + 256;
    }

    //console.log(image);
    context.putImageData(image, 0, 0);
    tools.renderer.hold_ui_context = true;
}

function clearTrace(){
    console.log("clear trace");
    tools.renderer.hold_ui_context = false;
}

function resetView(){
    //reset view to default
    tools.renderer.setDefaultView();
}

</script>
</head>
<body onload="onBodyLoad();">
	<div class="container">
	<canvas id="ui" style="border: none;" width="1024" height="720" oncontextmenu="return false;"></canvas>
	<canvas id="webgl" style="border: none;" width="1024" height="720" oncontextmenu="return false;"></canvas>
	</div>
    <p align="center">
        <input id="loader" type="file" onchange='loadFile()' autocomplete="off">
        </p>
</body>
</html>