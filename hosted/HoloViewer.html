<html>
<head>
<title>GLB+VRM viewer</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1">
<style>
.container {
    position: relative;
    overflow: hidden;
}
#ui {
    background-color: transparent;  /* set 2D canvas to overlap webgl canvas and be transparent*/
    position: absolute;
    left: 0px;
    top: 0px;
    z-index: 10;
    overflow: hidden;
}

body {
  position: relative;
  margin: 0;
  padding: 0;
  overflow: hidden;
}
</style>

<script type="text/javascript" src="gl-matrix-min.js"></script>
<script type="text/javascript" src="HoloRenderer.js"></script>
<script type="text/javascript" src="InterfaceButton.js"></script>
<script type="text/javascript" src="ExecutionMode.js"></script>
<script type="text/javascript" src="generated/api.js"></script>
<script type="text/javascript" src="Serializer.js"></script>
<script type="text/javascript" src="HoloMode.js"></script>
<script type="text/javascript" src="TableClient.js"></script>

<script id="shader-fs" type="x-shader/x-fragment">#version 300 es
    // Fragment shader for rendering multi-image holograms
    precision mediump float;

    
    uniform vec3 view_position ; //camera position
	in vec3 v_position; // point on render mesh in world space
	
    // Hologram packeted into textures by type
    const int texture_width = 1024;// needs to match the texture_width in HoloRenderer
    uniform sampler2D floats;
    uniform mediump isampler2D ints;
    uniform lowp usampler2D bytes;

	

	out vec4 frag_color; // output color

    // Pull a value out of the textures by index
    float getFloat(int index){
        int y = index/texture_width;
        int x = index - (y*texture_width) ;
        return texelFetch(floats, ivec2(x, y), 0).r;
    }

    int getInt(int index){
        int y = index/texture_width;
        int x = index - (y*texture_width) ;
        return texelFetch(ints, ivec2(x, y), 0).r;
    }

    uint getByte(int index){
        int y = index/texture_width;
        int x = index - (y*texture_width) ;
        return texelFetch(bytes, ivec2(x, y), 0).r;
    }

    // get the indices for the start of each panel
    int getPanelFloatPointer(int which){
        return getInt(2+which*3);
    }

    int getPanelIntPointer(int which){
        return getInt(2+ which*3+1);
    }

    int getPanelBytePointer(int which){
        return getInt(2 + which*3+2);
    }

    //get the indices for the start of each view
    int getViewFloatPointer(int which, int num_panels){
        return getInt(2+ which*3 + num_panels*3);
    }

    int getViewIntPointer(int which, int num_panels){
        return getInt(2 + which*3+1 + num_panels*3);
    }

    int getViewBytePointer(int which, int num_panels){
        return getInt(2 + which*3+2 + num_panels*3);
    }

    vec3 getPanelZero(int panel_float_pointer){
        return vec3(getFloat(panel_float_pointer), getFloat(panel_float_pointer+1), getFloat(panel_float_pointer+2));
    }

    vec3 getPanelX(int panel_float_pointer){
        return vec3(getFloat(panel_float_pointer+3), getFloat(panel_float_pointer+4), getFloat(panel_float_pointer+5));
    }

    vec3 getPanelY(int panel_float_pointer){
        return vec3(getFloat(panel_float_pointer+6), getFloat(panel_float_pointer+7), getFloat(panel_float_pointer+8));
    }

    vec3 getPanelZ(int panel_float_pointer){
        return vec3(getFloat(panel_float_pointer+9), getFloat(panel_float_pointer+10), getFloat(panel_float_pointer+11));
    }

    int getPanelWidth(int panel_int_pointer){
        return getInt(panel_int_pointer);
    }

    int getPanelHeight(int panel_int_pointer){
        return getInt(panel_int_pointer+1);
    }

    int getPanelDepthTexel(int panel_byte_pointer, int x, int y, int width){
        return int(getByte(panel_byte_pointer + width * y + x));
    }
    
    int getPanelDepthTexel(int panel_byte_pointer, int i){
        return int(getByte(panel_byte_pointer + i));
    }

    float getPanelDepthMap(int panel_float_pointer, int i){
        return getFloat(panel_float_pointer + 12 + i);
    }


    float rayPlaneIntersect(vec3 p, vec3 v, vec3 N, float d){
        return (-d - dot(N,p)) / dot(N,v) ;
    }


    vec3 getViewPosition(int view_float_pointer){
        return vec3(getFloat(view_float_pointer), getFloat(view_float_pointer+1), getFloat(view_float_pointer+2));
    }

    vec3 getViewNormal(int view_float_pointer){
        return vec3(getFloat(view_float_pointer+3), getFloat(view_float_pointer+4), getFloat(view_float_pointer+5));
    }

    mat3 getViewToPixel(int view_float_pointer){
        //TODO check for transpose
        return mat3(getFloat(view_float_pointer+6), getFloat(view_float_pointer+7), getFloat(view_float_pointer+8),
        getFloat(view_float_pointer+9), getFloat(view_float_pointer+10), getFloat(view_float_pointer+11),
        0.0, 0.0, 0.0);
    }

    float getViewDepthMap(int view_float_pointer, int i){
        return getFloat(view_float_pointer + 12 + i);
    }

    int getViewWidth(int view_int_pointer){
        return getInt(view_int_pointer);
    }

    int getViewHeight(int view_int_pointer){
        return getInt(view_int_pointer+1);
    }

    // [Red, Green, Blue, Depth]
    ivec4 getViewPixel(int view_int_pointer, int x, int y, int width){
        uint pix = uint(getInt(view_int_pointer+2 + y*width + x));
        return ivec4(int(pix)&0xff, int(pix>>8)&0xff, int(pix>>16)&0xff, int(pix>>24)&0xff);
    }



    // returns the position where the given ray first intersects the bounding box of this panel
    // or returns p if p is inside the panel already
    // returns 0,0,0 if the ray does not intersect the box TODO remove magic number
    vec3 getFirstPointInBox(vec3 p, vec3 v, vec3 zero_position, vec3 X, vec3 Y, vec3 Z, int width, int height, float max_depth_value){
    
        // Get t value intersection with the 6 sides of the bounding box
        vec3 N = X ;
        float d = -1.0f* dot(N, zero_position);
        float t1 = rayPlaneIntersect(p,v,N,d);
        d = -1.0f* dot(N, zero_position + X*float(width));
        float t2 = rayPlaneIntersect(p,v,N,d);
        float xmint = min(t1,t2);
        float xmaxt = max(t1,t2);

        N = Y ;
        d = -1.0f* dot(N, zero_position);
        t1 = rayPlaneIntersect(p,v,N,d);
        d = -1.0f* dot(N, zero_position + Y*float(height));
        t2 = rayPlaneIntersect(p,v,N,d);
        float ymint = min(t1,t2);
        float ymaxt = max(t1,t2);

        N = Z ;
        d = -1.0f* dot(N, zero_position);
        t1 = rayPlaneIntersect(p,v,N,d);
        d = -1.0f* dot(N, zero_position + Z*max_depth_value);
        t2 = rayPlaneIntersect(p,v,N,d);
        float zmint = min(t1,t2);
        float zmaxt = max(t1,t2);

        // get range of t intersection
        float mint = max(max(xmint,ymint),zmint) ;
        float maxt = min(min(xmaxt,ymaxt),zmaxt) ;

        vec3 result = vec3(0,0,0); 
        if(maxt >= mint && maxt >= 0.0){ // hits box
            float t = max(mint,0.0) ; // if started inside, then use that
            result = p + v * t; // return enter p
        }
        
        return result ;

    }

    // Returns the t for ray p+v*t  of the first pixel the given ray hits.
// returns -1 if no hit
// This function steps 1 pixel at a time, so you'll want to use other methods to step the ray closer to its intersection point before calling this
vec3 firstPointHit(vec3 p, vec3 v, vec3 zero_position, vec3 X, vec3 Y, vec3 Z, int width, int height, float max_depth_value, int panel_float_pointer, int panel_byte_pointer){
    float first_x = dot(p-zero_position, X)/dot(X,X);
    float first_y = dot(p-zero_position, Y)/dot(Y,Y);
    float first_z = dot(p-zero_position, Z)/dot(Z,Z);

    // get t value on sides of pixel column by intersecting ray with planes of pixel boundary
    float left_t = rayPlaneIntersect(p,v, X, - dot(X, zero_position + X*float(floor(first_x))));
    float right_t = rayPlaneIntersect(p,v, X, - dot(X, zero_position + X*float(floor(first_x)+1.0)));
    float top_t = rayPlaneIntersect(p,v, Y, - dot(Y, zero_position + Y*float(floor(first_y))));
    float bottom_t = rayPlaneIntersect(p,v, Y, - dot(Y, zero_position + Y*float(floor(first_y)+1.0)));

    // how ray t changes with movement in texture coordinates
    float tperx = right_t-left_t ;
    float tpery = bottom_t-top_t ;
    float zpert = dot(v, Z)/dot(Z,Z) ;

    float max_z = max_depth_value+0.001f ;
    //compute t that leaves the image outside loop so we only need to check one axis in the loop
    float exit_t = 99999.0 ;
    if(zpert > 0.0){
        exit_t = min(exit_t, (max_z-first_z)/zpert) ;
    }else{
        exit_t = min(exit_t, (0.0-first_z)/zpert) ;
    }

    if(tperx > 0.0){
        exit_t = min(exit_t, (float(width)-1.0-first_x)*tperx);
    }else{
        exit_t = min(exit_t, (1.0-first_x)*tperx);
    }

    if(tpery > 0.0){
        exit_t = min(exit_t, (float(height)-1.0-first_y)*tpery);
    }else{
        exit_t = min(exit_t, (1.0-first_y)*tpery);
    }

    int xstep  ;
    float nextx ;
    if(right_t > left_t){
        xstep = 1 ;
        nextx = right_t ;
    }else{
        xstep = -1;
        nextx = left_t ;
    }

    int ystep  ;
    float nexty ;
    if(bottom_t > top_t){
        ystep = 1 ;
        nexty = bottom_t ;
    }else{
        ystep = -1;
        nexty = top_t ;
    }

    int x = int(first_x) ;
    int y = int(first_y) ;
    float t = 0.0 ;
    float z = first_z ;

    // loop until z is in range or past the edge
    int i = y * width + x ;
    int yistep = width*ystep;
    int xistep = xstep;
    int depth = getPanelDepthTexel(panel_byte_pointer, i) ;
    float depth_value = getPanelDepthMap(panel_float_pointer,depth) ;
    float tperxstep = tperx*float(xstep) ;
    float tperystep = tpery*float(ystep) ;
    //while(z < max_z && x >=0 && x < width && y >=0 && y < height && z > getPanelDepthMap(panel_float_pointer,depth) && (depth > 0 || z >0)){
    while(t < exit_t && z > depth_value){ // while in box and not hitting a bar
        // step horizontally or vertically based on which you would hit next
        float next_t = nextx < nexty ? nextx : nexty ;
        z += zpert*(next_t-t) ;
        if(z > depth_value){ // if we wouldn't hit the bar before exiting this pixel
            // step to next pixel
            t = next_t ;
            if(nextx < nexty){
                nextx += tperxstep;
                x += xstep;
                i += xistep;
            }else{
                nexty += tperystep;
                y += ystep;
                i += yistep;
            }
            //fetch depth index and value
            depth = getPanelDepthTexel(panel_byte_pointer, i) ; //i = (y * width + x)*channels + depth_channel ;
            depth_value = getPanelDepthMap(panel_float_pointer,depth) ;
        }
    }

    if(z < max_z && x >=0 && x < width && y >=0 && y < height && depth > 0){
        return p+t*v;
    }else{
        return vec3(0.0,0.0,0.0) ;
    }
}


    vec3 getPointHit(int which_panel, vec3 p, vec3 v){
        int panel_float_pointer = getPanelFloatPointer(which_panel);
        int panel_int_pointer= getPanelIntPointer(which_panel);
        int panel_byte_pointer = getPanelBytePointer(which_panel);

        vec3 zero = getPanelZero(panel_float_pointer);
        vec3 X = getPanelX(panel_float_pointer);
        vec3 Y = getPanelY(panel_float_pointer);
        vec3 Z = getPanelZ(panel_float_pointer);
        float max_depth_value = getPanelDepthMap(panel_float_pointer,255);
        int width = getPanelWidth(panel_int_pointer);
        int height= getPanelHeight(panel_int_pointer);

        vec3 point = getFirstPointInBox(p, v, zero, X, Y, Z, width, height, max_depth_value);

        if(dot(point,point) > 0.01f){
            point = firstPointHit(p, v, zero, X, Y, Z, width, height, max_depth_value, panel_float_pointer, panel_byte_pointer) ;
        }
        return point ;
    }

    // return texturecoordinates given a direction vector from the image's viewpoint
    vec2 getTextureCoordinates(vec3 v, int view_float_pointer){
        mat3 to_pixel = getViewToPixel(view_float_pointer);
        vec3 normal = getViewNormal(view_float_pointer);
        vec3 iv = v / dot(v,normal); // project to plane of image 
        return vec2(iv * to_pixel) ;
    }
    
    vec3 getColor(int tx, int ty, int width, int view_int_pointer){
        ivec4 pixel = getViewPixel(view_int_pointer, tx, ty, width) ;
        return vec3(float(pixel[0])/255.0, float(pixel[1])/255.0, float(pixel[2])/255.0);
    }

    // get the color of a point this image can see
    vec3 getColor(vec3 p, int view_float_pointer, int view_int_pointer){
        vec3 position = getViewPosition(view_float_pointer);
        int width = getViewWidth(view_int_pointer);
        int height = getViewHeight(view_int_pointer);
        vec3 v = p - position ;
        vec2 tex = getTextureCoordinates(v, view_float_pointer);
        int tx = int(tex.x) ;
        int ty = int(tex.y) ;
        if(tx>= 0 && ty >= 0 && tx < width && ty < height){
            return getColor(tx,ty, width, view_int_pointer);
        }else{
            return vec3(0, 0, 0);
        }
    }
    

    vec3 getViewColor(int which_view, vec3 point, int num_panels){
        int view_float_pointer = getViewFloatPointer(which_view, num_panels);
        int view_int_pointer = getViewIntPointer(which_view, num_panels);
        return getColor(point, view_float_pointer, view_int_pointer);

    }


    // return true if the given point is visible by this image
    bool checkVisibility(vec3 p, int view_float_pointer, int view_int_pointer){
        vec3 normal = getViewNormal(view_float_pointer);
        vec3 position = getViewPosition(view_float_pointer);
        int width = getViewWidth(view_int_pointer);
        int height = getViewHeight(view_int_pointer);
        vec3 v = p - position ;
        float depth = dot(v,normal) ;

        
        if(depth < 0.0){ // behind camera
            return false;
        }
        
        
        vec2 tex = getTextureCoordinates(v, view_float_pointer);
        int tx = int(tex.x) ;
        int ty = int(tex.y) ;
        if(tx <= 0 || ty <= 0 || tx >= width || ty >= height){ // not in frame taken
            return false;
        }
        
        
        int di = getViewPixel(view_int_pointer, tx, ty, width)[3];
        if(di == 0 ){ // transparent pixel
            return true; // is visible cause we saw all the way through
        }
        float image_depth = getViewDepthMap(view_float_pointer, di) ;
        
        return depth <= image_depth*1.015 && depth >= image_depth*0.5; // occlusion check
        
    }

    void main(void) {

        vec3 p = view_position ;
        vec3 v = v_position - p ;

        int num_panels = getInt(0);
        int num_views = getInt(1);
        


        vec3 point = getPointHit(0, p,v);
        if(dot(point,point) > 0.01f ){

            int view_float_pointer = getViewFloatPointer(0, num_panels);
            int view_int_pointer = getViewIntPointer(0, num_panels);
            bool visiblefrom0 = checkVisibility(point, view_float_pointer, view_int_pointer) ;

        
            if(visiblefrom0){
                vec3 color = getViewColor(0,point,num_panels);
                frag_color = vec4(color, 1.0);
            }else{
                frag_color = vec4(0.0f, 0.0f, 0.1f, 1.0f);
            }

        }else{
            frag_color = vec4(0.0f, 0.0f, 0.0f, 1.0f);
        }

        

    }
</script>

<script id="shader-vs" type="x-shader/x-vertex">#version 300 es
    // A very simple passthrough vertex shader
	in vec3 input_vertex_position;
   
    uniform mat4 mv_matrix;
    uniform mat4 p_matrix;

	out vec3 v_position;

    void main(void) {
        gl_Position = p_matrix * mv_matrix * vec4(input_vertex_position, 1.0);
		v_position = input_vertex_position; 
    }
</script>

<script type="text/javascript">
"use strict";
const url_params = new URLSearchParams(window.location.search) ;
var app; // The main app running on the CAD canvas
var imports = url_params.get("import") ? url_params.get("import").split(',') : [];

var tools  ; // a map containing several things above so execution modes can access them
var views = 0, panels = 0 ;
var filename = "test";

function canvasApp() {
    //The canvas this app is running on.
	var theCanvas = document.getElementById("ui");
	// 2D context you can use to draw on.
    var context = theCanvas.getContext("2d");

    var mouse_x, mouse_y, mouse_down_x, mouse_down_y ;
    


	function init() {
        // Add event listeners to the canvas or window as appropriate
		theCanvas.addEventListener("mousedown", mouseDownListener, false);
		window.addEventListener("mousemove", mouseMoveListener, false);
		window.addEventListener("mouseup", mouseUpListener, false);
		window.addEventListener('keydown',keyDownListener,false);
		window.addEventListener('keyup',keyUpListener,false);
		window.addEventListener('mousewheel', mouseWheelListener);//For Chrome
        window.addEventListener('DOMMouseScroll', mouseWheelListener);// For Firefox

        //touchHandler simulates mouse events on single touch
		document.addEventListener("touchstart", touchHandler, true);
		document.addEventListener("touchmove", touchHandler, true);
		document.addEventListener("touchend", touchHandler, true);
		document.addEventListener("touchcancel", touchHandler, true);


        //document.addEventListener('pointermove', pointerMove, true) ;

        window.setInterval(timeListener, 1000.0/120.0);
	}

    function timeListener(){

        if(tools.current_mode!=null){
            if(tools.renderer.has_new_xr_input){
                tools.current_mode.vrInputSourcesUpdated(tools.renderer.xr_input);
                tools.renderer.has_new_xr_input = false;
            }
            tools.current_mode.timer();  

        }

        /*
        if(tools.table_link != null && tools.table_link.ready() && !tools.table_link.active){
            tools.table_link.sendPendingRequests(true); // This works to start even if there aren't any pending requests yet
        }
        */
    }

	function keyDownListener(evt) {
        if(tools.current_mode!=null){
            tools.current_mode.keyDownListener(evt);
        }
	}

	function keyUpListener(evt) {
        if(tools.current_mode!=null){
            tools.current_mode.keyUpListener(evt);
        }
    }

    // Map touchevents
	function touchHandler(event){
		//event.preventDefault();
		var touches = event.touches;
		var pointers = [];
		for(let k=0;k<touches.length;k++){
            //TODO get position relative to canvas if canvas isn't whole screen?
            /*
            this.mouse_down_x = (event.clientX - bRect.left)*(tools.canvas.width/bRect.width);
            this.mouse_down_y = (event.clientY - bRect.top)*(tools.canvas.height/bRect.height);
            */
			pointers.push({x: touches[k].clientX, y: touches[k].clientY, button:10}); // using 10 for touch events
		}
		switch(event.type)
		{
			case "touchstart": pointerDown(pointers); break;
			case "touchmove":  pointerMove(pointers); break;
			case "touchend":  pointerUp(pointers);   break;
			default:           return;
		}
	}

	function mouseDownListener(event) {
		pointerDown([{x:event.clientX, y:event.clientY, button:event.button}]);
    }

	function mouseMoveListener(event){
		pointerMove([{x:event.clientX, y:event.clientY, button:event.button}]);
	}
	function mouseUpListener(event){
		pointerUp([]); // On mouse up there are no pointers down
	}

 

	function pointerDown(pointers) {

        if(tools.renderer.xr_session != null){ // Kill XR session if interacting with canvas
            tools.renderer.xr_session.end().then(tools.renderer.onXRSessionEnded);
        }

		mouse_down_x = pointers[0].x;
        mouse_down_y = pointers[0].y;

        // Buttons are executed in mouse up, this just prevents calling underlying mode when clicking a button.
        let pressed_button = false;
        for (let button_name in tools.buttons) {
            if (tools.buttons.hasOwnProperty(button_name)) {
                var b = tools.buttons[button_name];
                if( b.inside(mouse_down_x, mouse_down_y)){
                    pressed_button = true;
                }
            }
        }

        if(tools.current_mode!=null && !pressed_button){
            tools.current_mode.pointerDown(pointers);
        }
	}

	function pointerUp(pointers) {
        // Execute buttons if it was clicked (mouse down and up on it)
        let pressed_button = false;
        for (let button_name in tools.buttons) {
            if (tools.buttons.hasOwnProperty(button_name)) {
                var b = tools.buttons[button_name];
                if(b.inside(mouse_x, mouse_y) && b.inside(mouse_down_x, mouse_down_y)){
                    b.execute();
                    pressed_button = true;
                }
            }
        }

        if(tools.current_mode!=null && !pressed_button){
            tools.current_mode.pointerUp(pointers);
        }
	}

	function pointerMove(pointers) {
        if(pointers.x){ // not an array, must be a real pointer event
            pointers.preventDefault()
            pointers = [{x:pointers.x,y:pointers.y}];
        }
        mouse_x = pointers[0].x;
		mouse_y = pointers[0].y;
        if(tools.current_mode!=null){
            tools.current_mode.pointerMove(pointers);
        }
    }

	function mouseWheelListener(evt){
        if(tools.current_mode!=null){
            tools.current_mode.mouseWheelListener(evt);
        }
	}



    init(); //TODO this a janky way to boot up an app, maybe change it?
}

// Switch main execution mode (expects mode to be an ExecutionMode)
function switchExecutionMode(next_mode){
    if(tools.current_mode != null){
        tools.current_mode.exit(next_mode);
    }
    var last_mode = tools.current_mode ;
    tools.current_mode = next_mode ;
    next_mode.enter(last_mode);

}


function initializeModes(){
    tools.modes = {} ;
    tools.modes.holo_mode = new HoloMode(tools);
    switchExecutionMode(tools.modes.holo_mode) ;
}

function setMainMenuButtons(){
    tools.buttons = {};
    tools.buttons["fps_label"] = new InterfaceButton(tools.canvas.width-80, 10, 80, 40, "FPS:?", 20, "#FFFFFF", "#000000", "#000000", 3, null);
    tools.buttons["views_label"] = new InterfaceButton(tools.canvas.width-90, 70, 90, 40, "views:0", 20, "#FFFFFF", "#000000", "#000000", 3, null);
    tools.buttons["enter_vr"] = new InterfaceButton(5, 10, 100, 40, "Enter VR", 14, "#D0D0F0", "#606060", "#FFFFFF", 3, () => {tools.renderer.startXRSession();});
    tools.buttons["resetView"] = new InterfaceButton(5, 50, 100, 40, "Reset View", 14, "#D0D0F0", "#606060", "#FFFFFF", 3, resetView);
    tools.buttons["holo_trace"] = new InterfaceButton(5, 150, 100, 40, "CPU trace", 14, "#D0D0F0", "#606060", "#FFFFFF", 3, holoTrace);
    tools.buttons["clear_trace"] = new InterfaceButton(5, 190, 100, 40, "Clear Trace", 14, "#D0D0F0", "#606060", "#FFFFFF", 3, clearTrace);
}

function onBodyLoad(){
    tools = {};
    tools.renderer = new HoloRenderer("webgl", "ui", "shader-fs", "shader-vs", 100);
    tools.canvas = document.getElementById("ui"); ;

    // Wait for the WASM module to finish loading before booting up the socket and app
    window.initializeCPPAPI().then(function(Module){
        tools.API = Module ;
        //tools.table_link = new TableClient(9004, tools.API);
        app = canvasApp(); // Start the app
        initializeModes();
        setMainMenuButtons();
    });
}

function loadFile() {

    var file  = document.getElementById('loader').files[0];
    console.log(file) ;
    var ext = file.name.split(".");
    filename = ext[ext.length-2] ;
    ext = ext[ext.length-1].toLowerCase();
    

	var reader  = new FileReader();
	reader.onloadend = function () {
        let load_data = new Int8Array(reader.result);
        //console.log(reader.result);
        if(load_data!= null){
            let params = {};
            params.data = load_data;
            if(ext == "glb" || ext == "vrm"){
                tools.renderer.removeMesh("default_avatar");
                let m = tools.API.call("setModel", params, new Serializer()) ;
            }else if(ext == "hi1"){
                let m = tools.API.call("loadHologram", load_data, new Serializer(), false,true) ;
                views = m.views ;
                panels=m.panels;
                tools.buttons["views_label"].text = "views: " + views;

                tools.renderer.addHologramFile("default_holo", load_data); 

            }else{
                console.log("file extension not recognized:" + ext);
            }
        }
    }

	if (file) {
		reader.readAsArrayBuffer(file);
	} else {
		console.log("Failed to read file");
	}
}


function getCameraTraceInput(){
    var trace_input ={};
    trace_input.width = tools.canvas.width;
    trace_input.height = tools.canvas.height;
    trace_input.camera_pos = new Float32Array(3);
    for(var k=0;k<3;k++){
        trace_input.camera_pos[k] = tools.renderer.camera_pos[k];
    }
    trace_input.pMatrix = new Float32Array(16);
    trace_input.mvMatrix = new Float32Array(16);
    for(var k=0;k<16;k++){
        trace_input.pMatrix[k] = tools.renderer.pMatrix[k];
        trace_input.mvMatrix[k] = tools.renderer.mvMatrix[k];
    }
    return trace_input ;
}

function holoTrace(){
    var context = tools.canvas.getContext("2d");;
    var image = context.createImageData(tools.canvas.width, tools.canvas.height);
    //console.log("Holo Tracing " + image.width +" x " + image.height +"...");
    
    let trace_input = getCameraTraceInput();
    //console.log("trace_input:");
    //console.log(trace_input);
    var trace_output = tools.API.call("getHologramTraceImage",trace_input, new Serializer());
    for(var k=0;k<trace_output.image.length;k++){
        image.data[k] = trace_output.image[k] >= 0  ? trace_output.image[k] : trace_output.image[k] + 256;
    }

    //console.log(image);
    context.putImageData(image, 0, 0);
    tools.renderer.hold_ui_context = true;
}

function clearTrace(){
    console.log("clear trace");
    tools.renderer.hold_ui_context = false;
}

function resetView(){
    //reset view to default
    tools.renderer.setDefaultView();
}

</script>
</head>
<body onload="onBodyLoad();">
	<div class="container">
	<canvas id="ui" style="border: none;" width="1024" height="720" oncontextmenu="return false;"></canvas>
	<canvas id="webgl" style="border: none;" width="1024" height="720" oncontextmenu="return false;"></canvas>
	</div>
    <p align="center">
        <input id="loader" type="file" onchange='loadFile()' autocomplete="off">
        </p>
</body>
</html>