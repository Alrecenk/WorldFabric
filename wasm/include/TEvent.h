#ifndef _TEVENT_H_
#define _TEVENT_H_ 1

#include "Variant.h"
#include "Timeline.h"
#include "TObject.h"
#include "glm/vec3.hpp"

#include <map>
#include <vector>
#include <string>
#include <memory>

class TObject;
class Timeline;

class TEvent{

    public:

        double time = 0 ; // time this event occurs
        int anchor_id; // The id of the TObject this event is anchored to (and the only object it can edit)
        short type = -1; // a numerical type you can check when you need to cast (if the overriders use it!)

        bool has_run = false; //whether the event has run yet
        bool disabled = false; // whether the event should run
        std::weak_ptr<TEvent> spawner ; // event that spawned this event if it was spawned by another timeline event
        double spawner_time = -1E30;

        bool wrote_anchor = false; // whether this event wrote to its anchor object last time it ran
        std::vector<std::weak_ptr<TEvent>> spawned_events ; //events spawned by this event when it was last run
        std::vector<std::weak_ptr<TObject>> read; // Objects this event read the last time it was run
        
        Timeline* timeline ; // a link to the timeline hois event is in
        std::weak_ptr<TEvent> weak_this ; // a weak pointer to the timeline shared pointer to use for safe links

        virtual ~TEvent() = default;

        // pointer to user defined function to generated typed TEvents for their app
        static std::unique_ptr<TEvent>(*generateTypedTEvent)(const Variant& serialized) ; 

         // Serialize this event's data, so it can be efficiently moved between timelines
        virtual std::map<std::string,Variant> serialize() const{
            printf("Serialize not defined for event!\n");
            return std::map<std::string,Variant> ();
        }

        // Set this event to data generated by its serialize method
        virtual void set(std::map<std::string,Variant>& serialized){
            printf("Set not defined for event!\n");
        }

        // Runs the event
        // This is what you need to override to implement your application
        // To maintain causality run should only interact with dynamic data by using the privided methods:
        // get(id), getMutable(), addEvent, createObject, deleteObject, and getCollisions
        virtual void run(){
            printf("Run not defined for event!\n");
        }

        // Unrun an event (remove data changes and rigger rerunsof all readers and disable all spawned events)
        void unrun();

        // Returns the latest data for the given object available to this event
        const std::weak_ptr<TObject> get(int id);

        // Returns a mutable version of the object this event is anchored to
        // This is how you edit objects from inside events.
        std::weak_ptr<TObject> getMutable();

        // Adds an event to the Timeline this event is in
        // If no time is set on the event it will be run at the earliest possible time
        void addEvent(std::unique_ptr<TEvent> e);

        // Creates an event that creates an object at the earliest possible time
        void createObject(std::unique_ptr<TObject> obj, std::unique_ptr<TEvent> on_created);

         // Creates an event that deletes an object at the earliest possible time
        void deleteObject(int id);

        // Returns the IDs of all TObjects colliding with the bounding sphere of the anchor object
        // at the time of this event
        std::vector<int> getCollisions();

        // Sends anotifcation which can be picked up outside the timeline by subscribers functions
        void notify(const std::string& trigger, const Variant& data);

        // Override this to provide an efficient deep copy of this object
        // If not overridden serialize and set will be used to copy your object (which will be inefficent)
        virtual std::unique_ptr<TEvent> deepCopy();

        void print() const;

        // clears all pointers to this event on objects it read from
        void clearReaderPointers();
        
};
#endif // #ifndef _TEVENT_H_