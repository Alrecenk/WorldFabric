#include "MoveObject.h"
#include "MovingObject.h"

using std::string ;
using std::map ;
using std::vector;
using glm::vec3;
using std::weak_ptr;
using std::shared_ptr;
using std::unique_ptr;


MoveObject::MoveObject(){

}
MoveObject::MoveObject(int moving_object, double move_step){
    anchor_id = moving_object;
    interval = move_step;
}

MoveObject::MoveObject(double move_step){
    anchor_id = -99999;
    interval = move_step;
}

MoveObject::~MoveObject() {}

// Serialize this event's data, so it can be efficiently moved between timelines
std::map<std::string,Variant> MoveObject::serialize() const{
    map<string,Variant> serial;
    serial["dt"] = Variant(interval);
    serial["s"] = Variant((byte)stop_on_hit);
    serial["t"] = Variant(time);
    serial["a"] = Variant(anchor_id);
    return serial;

}

// Set this event to data generated by its serialize method
void MoveObject::set(std::map<std::string,Variant>& serial){
    interval = serial["dt"].getDouble();
    stop_on_hit = (bool)serial["s"].getByte();
    time = serial["t"].getDouble();
    anchor_id = serial["a"].getInt();

}

// Runs the event
// This is what you need to override to implement your application
// To maintain causality run should only interact with dynamic data by using the privided methods:
// get(id), getMutable(), addEvent, createObject, deleteObject, and getCollisions
void MoveObject::run(){
    weak_ptr<TObject> ow = getMutable() ;
    if(auto og = ow.lock()){
        shared_ptr<MovingObject> o = std::static_pointer_cast<MovingObject>(og);
        o->position += o->velocity * (float)interval;
        //printf("Object moving to : %f,%f, %f\n", o->position.x, o->position.y, o->position.z);
        if(stop_on_hit){
            vector<int> collisions = getCollisions();
            if(collisions.size() != 0){
                o->velocity = vec3(0,0,0);
            }
        }
    }
        
    std::unique_ptr<MoveObject> next_tick = std::make_unique<MoveObject>(anchor_id, interval);
    next_tick->time = time + interval ;
    next_tick->stop_on_hit = stop_on_hit;
    addEvent(std::move(next_tick));
}