#include "MeshInstance.h"

#include "CreateObject.h"
//#include "SetMeshInstance.h"

using std::map;
using std::string;
using std::vector;
using glm::vec3;

MeshInstance::MeshInstance(){
    type = 1 ;
}

MeshInstance::MeshInstance(glm::vec3 p, float r,const std::string& name, const glm::mat4& m, const Variant& bones){
    position = p ;
    radius = r ;
    mesh_name = name;
    pose = m ;
    bone_data = bones.clone();
    type = 1 ;
}

MeshInstance::~MeshInstance() {}

// Serialize this object, so it can be efficiently moved between timelines
std::map<std::string,Variant> MeshInstance::serialize() const{
    //printf("serializing bouncing ball\n");
    map<string,Variant> serial;
    serial["p"] = Variant(position);
    serial["r"] = Variant(radius);
    serial["name"] = Variant(mesh_name);
    serial["pose"] = Variant(pose);
    serial["bones"] = bone_data.clone();
    return serial;
}

// Set this object to data generated by its serialize method
void MeshInstance::set(std::map<std::string,Variant>& serial){
    //printf("setting a bouncing ball\n");
    position = serial["p"].getVec3();
    radius = serial["r"].getFloat();
    mesh_name = serial["name"].getString();
    pose = serial["pose"].getMat4();
    bone_data = serial["bones"].clone();
}

// Override this to provide an efficient deep copy of this object
// If not overridden serialize and set will be used to copy your object (which will be inefficent)
std::unique_ptr<TObject> MeshInstance::deepCopy(){
    return std::make_unique<MeshInstance>(position, radius, mesh_name, pose, bone_data);
}

// Override this function to provide logic for interpolation after rollback or extrapolation for slowly updating objects
// If not overridden getObserved returns the raw value of the object
std::unique_ptr<TObject> MeshInstance::getObserved(double time, const std::weak_ptr<TObject> last_observed, double last_time){
    return deepCopy();
}

std::unique_ptr<TObject> MeshInstance::createObject(const Variant& serialized){
    if(serialized.type_ != Variant::OBJECT){
        printf("timeline attemped to create an object with a nonobject variant!\n");
    }
    auto map = serialized.getObject() ;
    std::unique_ptr<TObject> obj = std::make_unique<MeshInstance>();
    obj->set(map);
    return std::move(obj);
}

std::unique_ptr<TEvent> MeshInstance::createEvent(const Variant& serialized){
    return std::unique_ptr<TEvent>(nullptr);
    /*
    if(serialized.type_ == Variant::NULL_VARIANT){ // events can hold poiners to other events which may be null
        return std::unique_ptr<TEvent>(nullptr);
    }
    auto map = serialized.getObject() ;
    std::unique_ptr<TEvent> event = std::make_unique<SetMeshInstance>();
    event->set(map);
    return std::move(event);
    */
}