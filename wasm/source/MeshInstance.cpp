#include "MeshInstance.h"

#include "CreateObject.h"
#include "SetMeshInstance.h"
#include "ConvexShape.h"
#include "ConvexSolid.h"
#include "MoveSimpleSolid.h"
#include "SetConvexSolid.h"
#include "ApplySolidImpulse.h"
#include "ApplyTelekinesis.h"

using std::map;
using std::string;
using std::vector;
using glm::vec3;

MeshInstance::MeshInstance(){
    type = 1 ;
    has_collision = false;
}

MeshInstance::MeshInstance(glm::vec3 p, float r,const std::string& own,const std::string& name, const glm::mat4& m, const Variant& bones, bool compressed){
    position = p ;
    radius = r ;
    owner = own;
    mesh_name = name;
    pose = m ;
    bone_data = bones.clone();
    bones_compressed = compressed ;
    type = 1 ;
    has_collision = false;
}

MeshInstance::~MeshInstance() {}

// Serialize this object, so it can be efficiently moved between timelines
std::map<std::string,Variant> MeshInstance::serialize() const{
    //printf("serializing bouncing ball\n");
    map<string,Variant> serial;
    serial["p"] = Variant(position);
    serial["r"] = Variant(radius);
    serial["name"] = Variant(mesh_name);
    serial["own"] = Variant(owner);
    serial["pose"] = Variant(pose);
    serial["bones"] = bone_data.clone();
    serial["c"] = Variant(bones_compressed ? 1 : 0);
    serial["type"] = Variant(type);
    return serial;
}

// Set this object to data generated by its serialize method
void MeshInstance::set(std::map<std::string,Variant>& serial){
    position = serial["p"].getVec3();
    radius = serial["r"].getFloat();
    mesh_name = serial["name"].getString();
    owner = serial["own"].getString();
    pose = serial["pose"].getMat4();
    bone_data = serial["bones"].clone();
    bones_compressed = serial["c"].getInt() ;
}

// Override this to provide an efficient deep copy of this object
// If not overridden serialize and set will be used to copy your object (which will be inefficent)
std::unique_ptr<TObject> MeshInstance::deepCopy(){
    auto c = std::make_unique<MeshInstance>(position, radius, owner, mesh_name, pose, bone_data, bones_compressed);
    c->write_time = write_time ; // TODO write time should not be used for timeouts in this way
    return c ;
}

// Override this function to provide logic for interpolation after rollback or extrapolation for slowly updating objects
// If not overridden getObserved returns the raw value of the object
std::unique_ptr<TObject> MeshInstance::getObserved(double time, const std::weak_ptr<TObject> last_observed, double last_time){
    if(auto og = last_observed.lock()){
       std::shared_ptr<MeshInstance> last = std::static_pointer_cast<MeshInstance>(og);
    if(bones_compressed && last->bones_compressed && write_time - last->write_time > 0.01){
        // last_observed is at t = 0 and current is at t = 1 
        double target_time = time-mesh_interpolation_delay ;
        double t = (target_time - last->write_time)/(write_time - last->write_time);
        printf("time: %f, target: %f, write_time: %f, last_write: %f, t: %f\n", time, target_time, write_time, last->write_time, t);
        map<int, glm::quat> interpolated_bones ;
        //decompress the last observed bone data to use as basis for interpolation
        byte* data = last->bone_data.getByteArray();
        int num_set = last->bone_data.getArrayLength()/9;
        for(int k=0;k<num_set;k++){
            int node_id = data[k*9];
            glm::quat& r = interpolated_bones[node_id];
            r.x = ((short *)(data+k*9+1))[0]/32767.0f ;
            r.y = ((short *)(data+k*9+3))[0]/32767.0f ;
            r.z = ((short *)(data+k*9+5))[0]/32767.0f ;
            r.w = ((short *)(data+k*9+7))[0]/32767.0f ;
            glm::normalize(r) ;
        }

        //decompress the current bone data and interpolate as required
        data = bone_data.getByteArray();
        num_set = bone_data.getArrayLength()/9;
        for(int k=0;k<num_set;k++){
            int node_id = data[k*9];
            glm::quat r_now ;
            r_now.x = ((short *)(data+k*9+1))[0]/32767.0f ;
            r_now.y = ((short *)(data+k*9+3))[0]/32767.0f ;
            r_now.z = ((short *)(data+k*9+5))[0]/32767.0f ;
            r_now.w = ((short *)(data+k*9+7))[0]/32767.0f ;
            glm::normalize(r_now ) ;
            if(interpolated_bones.find(node_id) != interpolated_bones.end()){
                interpolated_bones[node_id] = GLTF::slerp(interpolated_bones[node_id], r_now, t);
            }else{
                interpolated_bones[node_id] = r_now ;
            }
        }

        // recompress (we have to since we don't know how many bones there are to return it uncompresssed)
        Variant bone_buffer;
        bone_buffer.makeFillableByteArray(interpolated_bones.size()*9);
        data = bone_buffer.getByteArray();
        int j = 0 ;
        for(auto& [node_id, r] : interpolated_bones){
            data[j] = node_id;
            j++;
            ((short *) (data+j))[0] = (short)(r.x*32767) ;
            j+=2;
            ((short *) (data+j))[0] = (short)(r.y*32767) ;
            j+=2;
            ((short *) (data+j))[0] = (short)(r.z*32767) ;
            j+=2;
            ((short *) (data+j))[0] = (short)(r.w*32767) ;
            j+=2;
        }

        auto c = std::make_unique<MeshInstance>(position, radius, owner, mesh_name, pose, bone_buffer, true);
        c->write_time = target_time ;
        return c ;
    }}
    return deepCopy() ;
}

std::unique_ptr<TObject> MeshInstance::createObject(const Variant& serialized){
    /*printf("Creating object:\n");
    serialized.printFormatted();*/

    if(serialized.type_ != Variant::OBJECT){
        printf("timeline attemped to create an object with a nonobject variant!\n");
    }
    auto map = serialized.getObject() ;
    int type = map["type"].getShort();
    std::unique_ptr<TObject> obj ;
    if(type == 1){
        obj = std::make_unique<MeshInstance>();
    }else if(type == 2){
        obj = std::make_unique<ConvexSolid>();
    }else if(type == 3){
        obj = std::make_unique<ConvexShape>();
    }else{
        printf("Unrecognized Object type\n");
        Variant(map).printFormatted();
    }

    obj->set(map);
    return std::move(obj);
}

std::unique_ptr<TEvent> MeshInstance::createEvent(const Variant& serialized){
    /*printf("Creating event:\n");
    serialized.printFormatted();
    */

    if(serialized.type_ == Variant::NULL_VARIANT){ // events can hold poiners to other events which may be null
        return std::unique_ptr<TEvent>(nullptr);
    }
    auto map = serialized.getObject() ;
    int type = map["type"].getShort();
    std::unique_ptr<TEvent> event ;
    if(type == 1){
        event = std::make_unique<CreateObject>();
    }else if(type == 2){
        event = std::make_unique<SetMeshInstance>();
    }else if(type == 3){
        event = std::make_unique<SetConvexSolid>();
    }else if(type == 4){
        event = std::make_unique<MoveSimpleSolid>();
    }else if(type == 5){
        event = std::make_unique<ApplySolidImpulse>();
    }else if(type == 6){
        event = std::make_unique<ApplyTelekinesis>();
    }else{
        printf("Unrecognized Event type\n");
        Variant(map).printFormatted();
    }
    event->set(map);
    return std::move(event);
}