#include "SetConvexSolid.h"
#include "ConvexSolid.h"

using std::string ;
using std::map ;
using std::weak_ptr;
using std::shared_ptr;
using std::unique_ptr;


SetConvexSolid::SetConvexSolid(){
    type = 3 ;
}
SetConvexSolid::SetConvexSolid(int solid_id, glm::vec3 p, glm::vec3 v, glm::quat o, glm::vec3 av, bool mv){
    anchor_id = solid_id;
    new_position = p ;
    new_velocity = v ;
    new_orientation = o;
    new_angular_velocity = av ;
    new_moveable = mv ;
    
    type = 3 ;
}

SetConvexSolid::~SetConvexSolid() {}

// Serialize this event's data, so it can be efficiently moved between timelines
std::map<std::string,Variant> SetConvexSolid::serialize() const {
    map<string,Variant> serial;
    serial["a"] = Variant(anchor_id);
    serial["t"] = Variant(time);
    serial["p"] = Variant(new_position);
    serial["v"] = Variant(new_velocity);
    serial["o"] = Variant(new_orientation);
    serial["w"] = Variant(new_angular_velocity);
    serial["z"] = Variant(new_moveable ? 1 : 0);
    serial["type"] = Variant(type);
    return serial;
}

// Set this event to data generated by its serialize method
void SetConvexSolid::set(std::map<std::string,Variant>& serialized){
    anchor_id = serialized["a"].getInt();
    time = serialized["t"].getDouble();
    new_position = serialized["p"].getVec3();
    new_velocity = serialized["v"].getVec3();
    new_orientation = serialized["o"].getQuat();
    new_angular_velocity = serialized["w"].getVec3();
    new_moveable = serialized["z"].getInt() == 1;
}

// Runs the event
// This is what you need to override to implement your application
// To maintain causality run should only interact with dynamic data by using the privided methods:
// get(id), getMutable(), addEvent, createObject, deleteObject, and getCollisions
void SetConvexSolid::run(){
    weak_ptr<TObject> ow = getMutable() ;
    if(auto og = ow.lock()){
        shared_ptr<ConvexSolid> self = std::static_pointer_cast<ConvexSolid>(og);
        self->position = new_position;
        self->velocity = new_velocity;
        self->orientation = new_orientation;
        self->angular_velocity = new_angular_velocity;
        self->moveable = new_moveable ;
        self->last_set_time = time ;
        weak_ptr<TObject> sw = get(self->shape_id) ; 
        if(auto sg = sw.lock()){ // if has a shape
            shared_ptr<ConvexShape> shape = std::static_pointer_cast<ConvexShape>(sg);
            self->radius = shape->radius; // keep radius up to date with shape
            self->computeWorldPlanes(shape);
        }

    }
}