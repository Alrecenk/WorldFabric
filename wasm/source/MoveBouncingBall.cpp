#include "MoveBouncingBall.h"
#include "BouncingBall.h"
#include "BallWall.h"
#include "ApplyBallImpulse.h"

using std::string ;
using std::map ;
using std::vector;
using glm::vec3;
using std::weak_ptr;
using std::shared_ptr;
using std::unique_ptr;


float MoveBouncingBall::friction = 0 ;

MoveBouncingBall::MoveBouncingBall(){
    type = 2 ;
}
MoveBouncingBall::MoveBouncingBall(int moving_object, double move_step){
    anchor_id = moving_object;
    interval = move_step;
    type = 2 ;
}

MoveBouncingBall::MoveBouncingBall(double move_step){
    anchor_id = -99999;
    interval = move_step;
    type = 2 ;
}

MoveBouncingBall::~MoveBouncingBall() {}

// Serialize this event's data, so it can be efficiently moved between timelines
std::map<std::string,Variant> MoveBouncingBall::serialize() const{
    //printf("serializing move bouncing ball\n");
    map<string,Variant> serial;
    serial["dt"] = Variant(interval);
    serial["t"] = Variant(time);
    serial["a"] = Variant(anchor_id);
    return serial;

}

// Set this event to data generated by its serialize method
void MoveBouncingBall::set(std::map<std::string,Variant>& serial){
    interval = serial["dt"].getDouble();
    time = serial["t"].getDouble();
    anchor_id = serial["a"].getInt();

}

// Runs the event
// This is what you need to override to implement your application
// To maintain causality run should only interact with dynamic data by using the privided methods:
// get(id), getMutable(), addEvent, createObject, deleteObject, and getCollisions
void MoveBouncingBall::run(){
    weak_ptr<TObject> ow = getMutable() ;
    if(auto og = ow.lock()){
        shared_ptr<BouncingBall> self = std::static_pointer_cast<BouncingBall>(og);
        
        self->position += self->velocity * (float)interval;
        float speed = glm::length(self->velocity);
        if(speed > 0){
            float new_speed = fmax(0,speed-MoveBouncingBall::friction*interval);
            self->velocity *= new_speed/speed;
        }

        vector<int> collisions = getCollisions();
        for(int j = 0 ;j < collisions.size();j++){
            
            weak_ptr<TObject> cw = get(collisions[j]) ; 

            if(auto cg = cw.lock()){
                vec3 closest_point = vec3(10E30,10E30,10E30) ;
                if(cg->type == 1 ) { //ball
                    if(collisions[j] < anchor_id){ // only handle each collision once

                        shared_ptr<BouncingBall> c = std::static_pointer_cast<BouncingBall>(cg);
                        vec3 to_other = c->position - self->position  ;
                        float distance = glm::length(to_other) ;
                        if(distance < self->radius + c->radius && glm::dot(self->velocity - c->velocity, to_other) > 0 ){
                            vec3 impulse = to_other *(glm::dot((self->velocity * (self->radius*self->radius)) - (c->velocity * (c->radius*c->radius)), to_other) /glm::dot(to_other,to_other));
                            addEvent(std::make_unique<ApplyBallImpulse>(collisions[j], impulse));
                            self->velocity -= impulse/(self->radius*self->radius);
                        }
                    }
                    
                }else if(cg->type == 2 ){ // wall

                    vector<std::pair<vec3,vec3>> lines ;
                    shared_ptr<BallWall> w = std::static_pointer_cast<BallWall>(cg);
                    lines.push_back(std::pair<vec3,vec3>(vec3(w->min.x, w->min.y, self->position.z), vec3(w->min.x, w->max.y, self->position.z))) ;
                    lines.push_back(std::pair<vec3,vec3>(vec3(w->max.x, w->max.y, self->position.z), vec3(w->min.x, w->max.y, self->position.z))) ;
                    lines.push_back(std::pair<vec3,vec3>(vec3(w->min.x, w->min.y, self->position.z), vec3(w->max.x, w->min.y, self->position.z))) ;
                    lines.push_back(std::pair<vec3,vec3>(vec3(w->max.x, w->max.y, self->position.z), vec3(w->max.x, w->min.y, self->position.z))) ;
                    float best = 1E30;
                    for(auto& line : lines){
                        vec3 lp = getClosestPoint(line, self->position);
                        float dist2 = glm::dot(lp - self->position, lp - self->position) ;
                        if(dist2 < best){
                            best = dist2;
                            closest_point = lp ;
                        }
                    }   

                    vec3 to_hit = closest_point - self->position ;
                    double dist = glm::length(to_hit) ;
                    if(dist < self->radius){ // if actually hit
                        //mirror as though hitting a nonmovable object
                        to_hit *=1.0f/dist ; 
                        if(glm::dot(self->velocity, to_hit) > 0){//don't remirror if already turned away but still colliding
                            vec3 c = to_hit * glm::dot(self->velocity,to_hit);
                            self->velocity -= c * 2.0f ;
                        }
                    }
                }
                
            }
        }
    }

    std::unique_ptr<MoveBouncingBall> next_tick = std::make_unique<MoveBouncingBall>(anchor_id, interval);
    next_tick->time = time + interval ;
    addEvent(std::move(next_tick));
}


glm::vec3 MoveBouncingBall::getClosestPoint(std::pair<glm::vec3,glm::vec3> lines, glm::vec3 point){
    vec3 ac = point-lines.first;
    vec3 ab = lines.second-lines.first;
    float t = glm::dot(ac, ab) / glm::dot(ab,ab) ;
    t = fmax(0,fmin(t,1));
    return lines.first + (ab * t) ;
}