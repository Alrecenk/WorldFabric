#include "MoveBouncingBall.h"
#include "BouncingBall.h"

using std::string ;
using std::map ;
using std::vector;
using glm::vec3;


MoveBouncingBall::MoveBouncingBall(){

}
MoveBouncingBall::MoveBouncingBall(int moving_object, double move_step){
    anchor_id = moving_object;
    interval = move_step;
}

MoveBouncingBall::MoveBouncingBall(double move_step){
    anchor_id = -99999;
    interval = move_step;
}

MoveBouncingBall::~MoveBouncingBall() {}

// Serialize this event's data, so it can be efficiently moved between timelines
std::map<std::string,Variant> MoveBouncingBall::serialize() const{
    map<string,Variant> serial;
    serial["dt"] = Variant(interval);
    serial["t"] = Variant(time);
    serial["a"] = Variant(anchor_id);
    return serial;

}

// Set this event to data generated by its serialize method
void MoveBouncingBall::set(std::map<std::string,Variant>& serial){
    interval = serial["dt"].getDouble();
    time = serial["t"].getDouble();
    anchor_id = serial["a"].getInt();

}

// Runs the event
// This is what you need to override to implement your application
// To maintain causality run should only interact with dynamic data by using the privided methods:
// get(id), getMutable(), addEvent, createObject, deleteObject, and getCollisions
void MoveBouncingBall::run(){
    BouncingBall* o = (BouncingBall*)getMutable() ;
    o->position += o->velocity * (float)interval;
    //printf("Object moving to : %f,%f, %f\n", o->position.x, o->position.y, o->position.z);
    /*
    if(stop_on_hit){
        vector<int> collisions = getCollisions();
        if(collisions.size() != 0){
             o->velocity = vec3(0,0,0);
        }
    }
    */
    if(o->position.x + o->radius > o->box_max.x){
        o->position.x = o->box_max.x - o->radius;
        o->velocity.x *= -1 ;
    }
    if(o->position.y + o->radius > o->box_max.y){
        o->position.y = o->box_max.y - o->radius;
        o->velocity.y *= -1 ;
    }
    if(o->position.x - o->radius < o->box_min.x){
        o->position.x = o->box_min.x + o->radius;
        o->velocity.x *= -1 ;
    }
    if(o->position.y - o->radius < o->box_min.y){
        o->position.y = o->box_min.y + o->radius;
        o->velocity.y *= -1 ;
    }

    vector<int> collisions = getCollisions();
    if(collisions.size()>0){
        const BouncingBall* c = (const BouncingBall*)get(collisions[0]) ;
        vec3 to_hit = c->position - o->position ;
        to_hit = glm::normalize(to_hit);
        if(glm::dot(o->velocity, to_hit) > 0){
            vec3 c = to_hit * glm::dot(o->velocity,to_hit);
            o->velocity -= c * 2.0f ;
            //o->velocity.x *= -1;
            //o->velocity.y *= -1 ;
        }
    }

    std::unique_ptr<MoveBouncingBall> next_tick = std::make_unique<MoveBouncingBall>(anchor_id, interval);
    next_tick->time = time + interval ;
    addEvent(std::move(next_tick));
}