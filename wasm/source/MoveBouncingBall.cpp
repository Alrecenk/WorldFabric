#include "MoveBouncingBall.h"
#include "BouncingBall.h"

using std::string ;
using std::map ;
using std::vector;
using glm::vec3;
using std::weak_ptr;
using std::shared_ptr;
using std::unique_ptr;


MoveBouncingBall::MoveBouncingBall(){

}
MoveBouncingBall::MoveBouncingBall(int moving_object, double move_step){
    anchor_id = moving_object;
    interval = move_step;
}

MoveBouncingBall::MoveBouncingBall(double move_step){
    anchor_id = -99999;
    interval = move_step;
}

MoveBouncingBall::~MoveBouncingBall() {}

// Serialize this event's data, so it can be efficiently moved between timelines
std::map<std::string,Variant> MoveBouncingBall::serialize() const{
    //printf("serializing move bouncing ball\n");
    map<string,Variant> serial;
    serial["dt"] = Variant(interval);
    serial["t"] = Variant(time);
    serial["a"] = Variant(anchor_id);
    return serial;

}

// Set this event to data generated by its serialize method
void MoveBouncingBall::set(std::map<std::string,Variant>& serial){
    interval = serial["dt"].getDouble();
    time = serial["t"].getDouble();
    anchor_id = serial["a"].getInt();

}

// Runs the event
// This is what you need to override to implement your application
// To maintain causality run should only interact with dynamic data by using the privided methods:
// get(id), getMutable(), addEvent, createObject, deleteObject, and getCollisions
void MoveBouncingBall::run(){
    weak_ptr<TObject> ow = getMutable() ;
    if(auto og = ow.lock()){
        shared_ptr<BouncingBall> o = std::static_pointer_cast<BouncingBall>(og);
        o->position += o->velocity * (float)interval;

        if(o->position.x + o->radius > o->box_max.x){
            o->position.x = o->box_max.x - o->radius;
            o->velocity.x *= -1 ;
        }
        if(o->position.y + o->radius > o->box_max.y){
            o->position.y = o->box_max.y - o->radius;
            o->velocity.y *= -1 ;
        }
        if(o->position.x - o->radius < o->box_min.x){
            o->position.x = o->box_min.x + o->radius;
            o->velocity.x *= -1 ;
        }
        if(o->position.y - o->radius < o->box_min.y){
            o->position.y = o->box_min.y + o->radius;
            o->velocity.y *= -1 ;
        }

        vector<int> collisions = getCollisions();
        /*
        if(collisions.size()>0){
            const BouncingBall* c = (const BouncingBall*)get(collisions[0]) ;
            vec3 to_hit = c->position - o->position ;
            to_hit = glm::normalize(to_hit);
            if(glm::dot(o->velocity, to_hit) > 0){
                vec3 c = to_hit * glm::dot(o->velocity,to_hit);
                o->velocity -= c * 2.0f ;
                //o->velocity.x *= -1;
                //o->velocity.y *= -1 ;
            }
        }
        */
    }

    std::unique_ptr<MoveBouncingBall> next_tick = std::make_unique<MoveBouncingBall>(anchor_id, interval);
    next_tick->time = time + interval ;
    addEvent(std::move(next_tick));
}