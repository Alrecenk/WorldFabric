#include "BouncingBall.h"

using std::map;
using std::string;
using std::vector;

BouncingBall::BouncingBall(){}

BouncingBall::BouncingBall(glm::vec3 p, glm::vec3 v, float r, glm::vec3 min, glm::vec3 max){
    position = p ;
    velocity = v;
    radius = r ;
    box_min = min ;
    box_max = max ;
}

BouncingBall::~BouncingBall() {}

// Serialize this object, so it can be efficiently moved between timelines
std::map<std::string,Variant> BouncingBall::serialize() const{
    //printf("serializing bouncing ball\n");
    map<string,Variant> serial;
    serial["p"] = Variant(position);
    serial["v"] = Variant(velocity);
    serial["min"] = Variant(box_min);
    serial["max"] = Variant(box_max);
    serial["r"] = Variant(radius);
    return serial;
}

// Set this object to data generated by its serialize method
void BouncingBall::set(std::map<std::string,Variant>& serial){
    //printf("setting a bouncing ball\n");
    position = serial["p"].getVec3();
    velocity = serial["v"].getVec3();
    box_min = serial["min"].getVec3();
    box_max = serial["max"].getVec3();
    radius = serial["r"].getFloat();
    //printf("finished setting a bouncing ball\n");
}

// Override this to provide an efficient deep copy of this object
// If not overridden serialize and set will be used to copy your object (which will be inefficent)
std::unique_ptr<TObject> BouncingBall::deepCopy(){
    return std::make_unique<BouncingBall>(position, velocity, radius, box_min, box_max);
}

// Override this function to provide logic for interpolation after rollback or extrapolation for slowly updating objects
// If not overridden getObserved returns the raw value of the object
std::unique_ptr<TObject> BouncingBall::getObserved(const std::weak_ptr<TObject> last_observed){
    return deepCopy();
}