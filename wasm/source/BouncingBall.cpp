#include "BouncingBall.h"

#include "CreateObject.h"
#include "MoveBouncingBall.h"
#include "ChangeBallVelocity.h"

using std::map;
using std::string;
using std::vector;

BouncingBall::BouncingBall(){}

BouncingBall::BouncingBall(glm::vec3 p, glm::vec3 v, float r, glm::vec3 min, glm::vec3 max){
    position = p ;
    velocity = v;
    radius = r ;
    box_min = min ;
    box_max = max ;
}

BouncingBall::BouncingBall(glm::vec3 p, glm::vec3 v, float r){
    position = p ;
    velocity = v;
    radius = r ;
}

BouncingBall::~BouncingBall() {}

// Serialize this object, so it can be efficiently moved between timelines
std::map<std::string,Variant> BouncingBall::serialize() const{
    //printf("serializing bouncing ball\n");
    map<string,Variant> serial;
    serial["p"] = Variant(position);
    serial["v"] = Variant(velocity);
    serial["min"] = Variant(box_min);
    serial["max"] = Variant(box_max);
    serial["r"] = Variant(radius);
    return serial;
}

// Set this object to data generated by its serialize method
void BouncingBall::set(std::map<std::string,Variant>& serial){
    //printf("setting a bouncing ball\n");
    position = serial["p"].getVec3();
    velocity = serial["v"].getVec3();
    box_min = serial["min"].getVec3();
    box_max = serial["max"].getVec3();
    radius = serial["r"].getFloat();
    //printf("finished setting a bouncing ball\n");
}

// Override this to provide an efficient deep copy of this object
// If not overridden serialize and set will be used to copy your object (which will be inefficent)
std::unique_ptr<TObject> BouncingBall::deepCopy(){
    return std::make_unique<BouncingBall>(position, velocity, radius, box_min, box_max);
}

// Override this function to provide logic for interpolation after rollback or extrapolation for slowly updating objects
// If not overridden getObserved returns the raw value of the object
std::unique_ptr<TObject> BouncingBall::getObserved(const std::weak_ptr<TObject> last_observed){
    return deepCopy();
}

std::unique_ptr<TObject> BouncingBall::createObject(const Variant& serialized){
    //printf("callec create ball object!\n");
    //serialized.printFormatted();
    if(serialized.type_ != Variant::OBJECT){
        printf("timeline attemped to create an object with a nonobject variabnt!\n");
    }
    auto map = serialized.getObject() ;
    auto o = std::make_unique<BouncingBall>();
    o->set(map);
    return std::move(o);
}

std::unique_ptr<TEvent> BouncingBall::createEvent(const Variant& serialized){
    
    //TODO add a type system to make this check more intuitive
    if(serialized.type_ == Variant::NULL_VARIANT){ // events can hold poiners to other events which may be null
        return std::unique_ptr<TEvent>(nullptr);
    }
    auto map = serialized.getObject() ;
    std::unique_ptr<TEvent> event ;
    //TODO better way to distinguish event types
    if(map["o"].type_ == Variant::OBJECT){
        event = std::make_unique<CreateObject>();
    }else if(map["dt"].type_ == Variant::DOUBLE){
        event = std::make_unique<MoveBouncingBall>();
    }else if(map["v"].type_ == Variant::FLOAT_ARRAY){
        event = std::make_unique<ChangeBallVelocity>();
    }else{
        printf("Event not parsed!\n");
        serialized.printFormatted();
        //event = std::make_unique<ChangeVelocity>();
    }
    event->set(map);
    return std::move(event);
}