#include "ApplySolidImpulse.h"
#include "ConvexSolid.h"

using std::string ;
using std::map ;
using std::weak_ptr;
using std::shared_ptr;
using std::unique_ptr;


ApplySolidImpulse::ApplySolidImpulse(){
    type = 5 ;
}
ApplySolidImpulse::ApplySolidImpulse(int solid_id, glm::vec3 nimpulse, glm::vec3 npoint){
    anchor_id = solid_id;
    impulse = nimpulse;
    point = npoint ;
    type = 5 ;
}

ApplySolidImpulse::~ApplySolidImpulse() {}

// Serialize this event's data, so it can be efficiently moved between timelines
std::map<std::string,Variant> ApplySolidImpulse::serialize() const {
    map<string,Variant> serial;
    serial["a"] = Variant(anchor_id);
    serial["t"] = Variant(time);
    serial["p"] = Variant(point);
    serial["i"] = Variant(impulse);
    serial["type"] = Variant(type);
    return serial;
}

// Set this event to data generated by its serialize method
void ApplySolidImpulse::set(std::map<std::string,Variant>& serialized){
    anchor_id = serialized["a"].getInt();
    time = serialized["t"].getDouble();
    point = serialized["p"].getVec3();
    impulse = serialized["i"].getVec3();
}

// Runs the event
// This is what you need to override to implement your application
// To maintain causality run should only interact with dynamic data by using the privided methods:
// get(id), getMutable(), addEvent, createObject, deleteObject, and getCollisions
void ApplySolidImpulse::run(){
    weak_ptr<TObject> ow = getMutable() ;
    if(auto og = ow.lock()){
        shared_ptr<ConvexSolid> self = std::static_pointer_cast<ConvexSolid>(og);
        self->applyImpulse(impulse, point);

        weak_ptr<TObject> sw = get(self->shape_id) ; 
        if(auto sg = sw.lock()){ // if has a shape
            shared_ptr<ConvexShape> shape = std::static_pointer_cast<ConvexShape>(sg);
            self->radius = shape->radius; // keep radius up to date with shape
            self->computeWorldPlanes(shape);
        }
    }
}